# -*- coding: utf-8 -*-
"""male_female_upd.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15eWi-tZ2LwTaGjKZaOJaj_27D3KNKXVK
"""

!pip install ultralytics==8.2.2

from google.colab import drive
drive.mount('/content/drive')

# dostęp do plików na Google Drive
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

# Załaduj plik z danymi
df = pd.read_excel('/content/drive/MyDrive/Klasyfikator_nowy/Prace ML/ODIR-5K/full_df.xlsx')
print(df.head())

# Ścieżka do katalogu z obrazami ( u mnie był to Eyes wrzucony na Google Drive)
image_dir = '/content/drive/MyDrive/Klasyfikator_nowy/Prace ML/ODIR-5K/allphotos'

import os
# Stwórz listę dostępnych plików
available_images = set(os.listdir(image_dir))

# Sprawdź, które pliki w DF są dostępne
df['is_available'] = df['filename'].apply(lambda x: x in available_images)

# Filtruj tylko te wiersze, które mają dostępne zdjęcia
df_filtered = df[df['is_available'] == True]

df_filtered

# Sprawdź liczbę dostępnych zdjęć
print(f"Liczba dostępnych zdjęć: {len(df_filtered)}")

from sklearn.model_selection import train_test_split

# Zastąp wartości 'Female' i 'Male' liczbami
df_filtered['label'] = df_filtered['Patient Sex'].map({'Female': 0, 'Male': 1})

# Podziel dane na zbalansowane zestawy (wytyczne z pliku 80% train, 10% val, 10% test)
train_df, temp_df = train_test_split(df_filtered, test_size=0.2, stratify=df_filtered['label'], random_state=42)
val_df, test_df = train_test_split(temp_df, test_size=0.5, stratify=temp_df['label'], random_state=42)

import shutil

# Definiujemy ścieżki dla katalogów
base_dir = '/content/dataset/images'

# Tworzymy katalogi dla treningu, walidacji i testu, a w nich dla klas "Male" i "Female"
for subset in ['train', 'val', 'test']:
    for class_name in ['Male', 'Female']:
        os.makedirs(f'{base_dir}/{subset}/{class_name}', exist_ok=True)

# Funkcja do przenoszenia plików do odpowiednich folderów na podstawie klasy
def move_files(df, subset):
    for _, row in df.iterrows():
        class_name = 'Female' if row['label'] == 0 else 'Male'  # Nazwa klasy
        img_src = os.path.join(image_dir, row['filename'])  # Ścieżka do obrazu
        img_dest = f'{base_dir}/{subset}/{class_name}/' + row['filename']
        shutil.copy(img_src, img_dest)

# Liczba danych w zbiorze treningowym

len(train_df)

train_df['label'].value_counts()

# Liczba danych w zbiorze walidacyjnym

len(val_df)

val_df['label'].value_counts()

# Liczba danych w zbiorze testowym

len(test_df)

test_df['label'].value_counts()

# Przenieś dane do odpowiednich folderów (utwórz je)
!mkdir -p /content/dataset/images/train
!mkdir -p /content/dataset/images/val
!mkdir -p /content/dataset/images/test

# Przenieś
move_files(train_df, 'train')
move_files(val_df, 'val')
move_files(test_df, 'test')

from ultralytics import YOLO

# Inicjalizacja modelu YOLOv8 z wstępnie wytrenowaną siecią
model = YOLO('yolov8n-cls.pt')  # Wersja klasyfikacji

# Rozpocznij trening modelu
model.train(data='/content/dataset/images/', epochs=10, batch=16, imgsz=512)

# Ewaluacja modelu na zestawie testowym
metrics = model.val(data='/content/dataset/images/', split='test')

# Wyświetl wyniki ewaluacji
print(metrics)

# Zipujemy wytrenowany model i dataset (podzielony na zbiory train-val-test), a także przebieg treningu (runs)
!zip -r model_and_data.zip yolov8n-cls.pt /content/dataset /content/runs

# Pobieramy dane na komputer
from google.colab import files
files.download('model_and_data.zip')

import os
import shutil

# Ścieżki do katalogów Male i Female
male_test_dir = '/content/dataset/images/test/Male'
female_test_dir = '/content/dataset/images/test/Female'

# Ścieżka do głównego katalogu testowego (gdzie YOLOv8 oczekuje obrazów)
test_dir = '/content/dataset/images/test'

# Przenosimy wszystkie obrazy z katalogów Male i Female do głównego katalogu testowego
for class_dir in [male_test_dir, female_test_dir]:
    for filename in os.listdir(class_dir):
        file_path = os.path.join(class_dir, filename)
        shutil.move(file_path, test_dir)

os.rmdir(male_test_dir)
os.rmdir(female_test_dir)

# Przykład predykcji na zestawie testowym
results = model.predict(source='/content/dataset/images/test', save=True)

# Pobranie przewidywanych klas
y_pred = []

for result in results:
    # Pobierz prawdopodobieństwa (probs)
    probabilities = result.probs  # To jest obiekt zawierający prawdopodobieństwa
    predicted_class = probabilities.top1  # Pobiera klasę z najwyższym prawdopodobieństwem
    y_pred.append(predicted_class)

# Prawdziwe etykiety z zestawu testowego
y_true = test_df['label'].tolist()

from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# Obliczenie macierzy pomyłek
cm = confusion_matrix(y_true, y_pred)

# Wizualizacja macierzy pomyłek
plt.figure(figsize=(8,6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Female', 'Male'], yticklabels=['Female', 'Male'])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix')
plt.show()

from sklearn.metrics import classification_report

# Wyświetlenie szczegółowego raportu klasyfikacji
print(classification_report(y_true, y_pred, target_names=['Female', 'Male']))

# A teraz macierz na całych danych (train + test + val)

full_df = pd.read_excel('/content/drive/MyDrive/Eyes/full_df.xlsx')

# Sprawdź dostępne pliki
available_images = set(os.listdir(image_dir))

# Przefiltruj dane na podstawie dostępnych obrazów
full_df['is_available'] = full_df['filename'].apply(lambda x: x in available_images)
full_df_filtered = full_df[full_df['is_available'] == True]

# Zastąp wartości 'Female' i 'Male' liczbami
full_df_filtered['label'] = full_df_filtered['Patient Sex'].map({'Female': 0, 'Male': 1})

# Utwórz katalog na pełny zestaw danych do predykcji
full_test_dir = '/content/full_dataset_test'
os.makedirs(full_test_dir, exist_ok=True)

# Skopiuj wszystkie dostępne obrazy do tego katalogu
for _, row in full_df_filtered.iterrows():
    img_src = os.path.join(image_dir, row['filename'])
    img_dest = os.path.join(full_test_dir, row['filename'])
    shutil.copy(img_src, img_dest)

# Wykonaj predykcję na pełnym zbiorze danych
results_full = model.predict(source=full_test_dir, save=True)

# Pobranie przewidywanych klas
y_pred_full = []

for result in results_full:
    predicted_class = result.probs.top1  # Pobiera klasę z najwyższym prawdopodobieństwem
    y_pred_full.append(predicted_class)

# Prawdziwe etykiety z pełnego zbioru danych
y_true_full = full_df_filtered['label'].tolist()

# Obliczenie macierzy pomyłek
cm_full = confusion_matrix(y_true_full, y_pred_full)

# Wizualizacja macierzy pomyłek
plt.figure(figsize=(8,6))
sns.heatmap(cm_full, annot=True, fmt='d', cmap='Blues', xticklabels=['Female', 'Male'], yticklabels=['Female', 'Male'])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix - Full Dataset')
plt.show()

# Wyświetlenie szczegółowego raportu klasyfikacji
print(classification_report(y_true_full, y_pred_full, target_names=['Female', 'Male']))

